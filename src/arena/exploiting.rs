use crate::interfaces::{
    GameState, Placement, Player, PlayerID, PointPlacement, Result, TicTacToeArena,
    TicTacToeReferee,
};

pub struct ExploitingArena<'arena> {
    active_player: usize,
    board: GameState,
    players: [&'arena mut (dyn Player); 2],
    referee: &'arena mut (dyn TicTacToeReferee),
}

impl<'arena> ExploitingArena<'arena> {
    pub fn new(
        starting_player: PlayerID,
        board: GameState,
        players: [&'arena mut dyn Player; 2],
        referee: &'arena mut dyn TicTacToeReferee,
    ) -> Self {
        let matching_players: Vec<_> = players
            .iter()
            .enumerate()
            .filter_map(|(n, cur)| {
                if cur.get_id() == starting_player {
                    Some(n)
                } else {
                    None
                }
            })
            .collect();

        match matching_players[..] {
            [] => panic!("No matching player found for ID {starting_player}"),
            [n] => Self {
                board,
                players,
                active_player: n,
                referee,
            },
            _ => panic!("Multiple matching player found for ID {starting_player}"),
        }
    }

    fn get_first_maximum_point_placement(
        board: &GameState,
        placement: &Placement,
    ) -> Option<PointPlacement> {
        board
            .joint_iter_2d(placement)
            .filter(|(_, cell, _)| cell.is_free())
            .filter(|(_, _, weight)| weight > &&0.0)
            .fold((None, 0.0), |(result_pp, max_weight), (pp, _, weight)| {
                if weight > &max_weight {
                    (Some(pp), *weight)
                } else {
                    (result_pp, max_weight)
                }
            })
            .0
    }
}

impl TicTacToeArena for ExploitingArena<'_> {
    fn do_next_move(&mut self) -> (Result, PlayerID, Option<PointPlacement>) {
        let cur_player = &mut self.players[self.active_player % 2];
        self.active_player += 1;
        let placements = cur_player.do_move(&self.board);
        let maybe_pp = ExploitingArena::get_first_maximum_point_placement(
            &self.board,
            &placements,
        );

        match maybe_pp {
            Some(pp) => {
                let result =
                    self.referee
                        .receive_move(&mut self.board, pp, cur_player.get_id());
                (result, cur_player.get_id(), Some(pp))
            }
            None => (Result::Defeat, cur_player.get_id(), None),
        }
    }

    fn get_board(&self) -> GameState {
        self.board.clone()
    }
}
