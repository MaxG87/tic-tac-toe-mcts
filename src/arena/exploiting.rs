use crate::interfaces::*;

pub struct ExploitingArena<'arena, const N: usize, const K: usize> {
    active_player: usize,
    board: Board<N>,
    players: [&'arena mut (dyn Player<N, K>); 2],
    referee: &'arena mut (dyn TicTacToeReferee<N, K>),
}

impl<'arena, const N: usize, const K: usize> ExploitingArena<'arena, N, K> {
    pub fn new(
        board: Board<N>,
        players: [&'arena mut dyn Player<N, K>; 2],
        referee: &'arena mut dyn TicTacToeReferee<N, K>,
    ) -> ExploitingArena<'arena, N, K> {
        ExploitingArena {
            active_player: 0,
            board,
            players,
            referee,
        }
    }

    fn get_first_maximum_point_placement(
        board: &Board<N>,
        placement: &Placement<N>,
    ) -> Option<PointPlacement> {
        let mut point_placement: Option<PointPlacement> = None;
        let mut weight: f32 = 0.0;

        // Get point placement candidates with weights
        for row in 0..board.rows() {
            for column in 0..board.columns() {
                let maybe_id = &board.board[row][column];
                let cur_weight = placement[row][column];
                if let Some(_) = maybe_id {
                    continue;
                } else if cur_weight == 0.0 {
                    continue;
                } else if cur_weight > weight {
                    point_placement = Some(PointPlacement { row, column });
                    weight = cur_weight;
                }
            }
        }
        return point_placement;
    }
}

impl<'arena, const N: usize, const K: usize> TicTacToeArena<N, K>
    for ExploitingArena<'arena, N, K>
{
    fn do_next_move(&mut self) -> (Option<Result>, PlayerID, Option<PointPlacement>) {
        let cur_player = &mut self.players[self.active_player % 2];
        self.active_player += 1;
        let placements = cur_player.do_move(&self.board);
        let maybe_point_placement =
            ExploitingArena::<N, K>::get_first_maximum_point_placement(&self.board, &placements);

        match maybe_point_placement {
            Some(point_placement) => {
                let maybe_result = self.referee.receive_move(
                    &mut self.board,
                    &point_placement,
                    cur_player.get_id(),
                );
                return (maybe_result, cur_player.get_id(), Some(point_placement));
            }
            None => {
                return (Some(Result::Defeat), cur_player.get_id(), None);
            }
        }
    }

    fn get_board(&self) -> Board<N> {
        self.board.clone()
    }
}
